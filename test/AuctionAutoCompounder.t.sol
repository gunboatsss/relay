// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.19;

import "src/Relay.sol";
import "src/Registry.sol";
import "src/auctionAutoCompounder/AuctionAutoCompounder.sol";
import "src/Optimizer.sol";
import "src/auctionAutoCompounder/AuctionAutoCompounderFactory.sol";

import "@velodrome/test/BaseTest.sol";

contract AuctionAutoCompounderTest is BaseTest {
    bytes AUCTION_FACTORY_BYTECODE = hex'608060405234801561001057600080fd5b50600436106100cf5760003560e01c806350d9d4721161008c5780638ed5e3a3116100665780638ed5e3a31461018d578063ca43205d146101a0578063cbd2bdfd146101b3578063ed3aed79146101c857600080fd5b806350d9d47214610168578063571a26a0146101705780637d97597d1461018357600080fd5b80630935861e146100d4578063165a533d1461010457806319351c8d1461011757806322ebb2731461012f578063336558831461014257806346c715fa14610155575b600080fd5b6100e76100e23660046104b0565b6101d2565b6040516001600160a01b0390911681526020015b60405180910390f35b6100e76101123660046104cb565b6101f2565b610121620f424081565b6040519081526020016100fb565b6100e761013d366004610516565b610211565b6100e761015036600461056b565b61022e565b6000546100e7906001600160a01b031681565b600154610121565b6100e761017e3660046105ca565b610249565b6101216201518081565b6100e761019b3660046105e3565b610273565b6100e76101ae366004610626565b610294565b6101bb6102b4565b6040516100fb9190610659565b6101216206978081565b60006101ec826000336201518062069780620f4240610316565b92915050565b60006102088585858562069780620f4240610316565b95945050505050565b60006102248686868686620f4240610316565b9695505050505050565b600061023e878787878787610316565b979650505050505050565b6001818154811061025957600080fd5b6000918252602090912001546001600160a01b0316905081565b600061028c8484846201518062069780620f4240610316565b949350505050565b60006102ad8383336201518062069780620f4240610316565b9392505050565b6060600180548060200260200160405190810160405280929190818152602001828054801561030c57602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116102ee575b5050505050905090565b6000610320610427565b6040516339466de560e11b81526001600160a01b03898116600483015288811660248301528781166044830152606482018790526084820186905260a482018590529192509082169063728cdbca9060c401600060405180830381600087803b15801561038c57600080fd5b505af11580156103a0573d6000803e3d6000fd5b505060018054808201825560009182527fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf60180546001600160a01b0319166001600160a01b03868116918217909255604051918c16945092507fbc4082f61ad2c1141396485591a31655629009271d5910d28313c0460ced44db9190a39695505050505050565b6000805461043d906001600160a01b0316610442565b905090565b6000808260601b9050604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528160148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f0949350505050565b80356001600160a01b03811681146104ab57600080fd5b919050565b6000602082840312156104c257600080fd5b6102ad82610494565b600080600080608085870312156104e157600080fd5b6104ea85610494565b93506104f860208601610494565b925061050660408601610494565b9396929550929360600135925050565b600080600080600060a0868803121561052e57600080fd5b61053786610494565b945061054560208701610494565b935061055360408701610494565b94979396509394606081013594506080013592915050565b60008060008060008060c0878903121561058457600080fd5b61058d87610494565b955061059b60208801610494565b94506105a960408801610494565b9350606087013592506080870135915060a087013590509295509295509295565b6000602082840312156105dc57600080fd5b5035919050565b6000806000606084860312156105f857600080fd5b61060184610494565b925061060f60208501610494565b915061061d60408501610494565b90509250925092565b6000806040838503121561063957600080fd5b61064283610494565b915061065060208401610494565b90509250929050565b6020808252825182820181905260009190848201906040850190845b8181101561069a5783516001600160a01b031683529284019291840191600101610675565b5090969550505050505056fea2646970667358221220fc9ab8b5ef8dd0c8b02910c919c69663d5c799586dc2218a043fc6ce0bc26c5b64736f6c63430008120033';

    uint256 tokenId;
    uint256 mTokenId;

    AuctionAutoCompounderFactory auctionAutoCompounderFactory;
    AuctionAutoCompounder auctionAutoCompounder;
    Optimizer optimizer;
    Registry keeperRegistry;
    Registry optimizerRegistry;
    LockedManagedReward lockedManagedReward;
    FreeManagedReward freeManagedReward;

    address[] bribes;
    address[] fees;
    address[][] tokensToClaim;
    address[] tokensToSweep;
    address[] recipients;

    constructor() {
        deploymentType = Deployment.FORK;
    }

    function _setUp() public override {
        vm.etch(0xE6aB098E8582178A76DC80d55ca304d1Dec11AD8, AUCTION_FACTORY_BYTECODE);
        vm.etch(0x12e3250114a4a8439f8feDcCD0CfCc41a4e7b572, hex'608060405234801561001057600080fd5b50600436106101cf5760003560e01c80635f90cda611610104578063cc9ae693116100a2578063d7e2036111610071578063d7e2036114610519578063dd88674c1461052c578063e6c09edf14610535578063fe9f841e1461054857600080fd5b8063cc9ae69314610466578063d38bfff414610479578063d6fbf2021461048c578063d77153a71461049557600080fd5b8063728cdbca116100de578063728cdbca1461041c5780637f5a7c7b1461042f57806388f3543a14610440578063c3a5273a1461045357600080fd5b80635f90cda6146103ec57806364b3772014610401578063712b373e1461040957600080fd5b8063325c25a2116101715780634c8541261161014b5780634c854126146103a05780634c94d219146103b35780635aa6e675146103c65780635bfa1b68146103d957600080fd5b8063325c25a214610346578063337f951d1461034f578063466772611461038d57600080fd5b80631aec4747116101ad5780631aec4747146102205780631e2a8d43146102335780631edbc5be146102465780631f1fcd511461032157600080fd5b806304611f41146101d457806308874d12146101fa578063107436121461020d575b600080fd5b6101e76101e23660046120b9565b61055b565b6040519081526020015b60405180910390f35b6101e76102083660046120d4565b6105c1565b6101e761021b3660046120d4565b610638565b6101e761022e3660046120f6565b6106cb565b6101e7610241366004612122565b610768565b6102c76102543660046121b6565b600760209081526000918252604091829020825180840190935280546001600160a01b038082168552600160a01b9091046001600160601b0390811693850193909352600182015460029092015492821692600160601b90920416906001600160801b0380821691600160801b90041685565b6040805186516001600160a01b0390811682526020978801516001600160601b039081169883019890985295909616908601529190921660608401526001600160801b0391821660808401521660a082015260c0016101f1565b6002546001600160a01b03165b6040516001600160a01b0390911681526020016101f1565b6101e760055481565b61036261035d3660046121b6565b6107b6565b604080516001600160a01b0395861681529490931660208501529183015260608201526080016101f1565b6101e761039b3660046121b6565b6108a7565b6101e76103ae3660046121cf565b6108c8565b6101e76103c13660046121b6565b610bac565b60005461032e906001600160a01b031681565b6101e76103e73660046120b9565b610d03565b6103ff6103fa366004612210565b610d0f565b005b6008546101e7565b6101e76104173660046121b6565b610df4565b6103ff61042a36600461226c565b6110ca565b6003546001600160a01b031661032e565b6101e761044e3660046121b6565b611397565b6101e76104613660046120d4565b6113a3565b6101e76104743660046121b6565b6113dd565b6103ff6104873660046120b9565b6113ed565b6101e760045481565b6040805160a0810182526003546001600160a01b038116825260ff600160a01b8204811615156020808501829052600160a81b840483161515858701819052600160b01b8504841615156060808801829052600160b81b909604909416151560809687018190528751938452918301529481019190915290810192909252016101f1565b6101e76105273660046122cb565b61146b565b6101e760065481565b6103ff6105433660046120b9565b611479565b6103ff610556366004612300565b611487565b6000816105706002546001600160a01b031690565b6040516bffffffffffffffffffffffff19606093841b8116602083015291831b821660348201523090921b166048820152605c01604051602081830303815290604052805190602001209050919050565b60028054600084815260076020526040812060018101548154919094015491936001600160601b03600160a01b94859004811694610625949282169361061693919004909116906001600160801b0316612340565b6001600160801b0316856116cb565b61062f9190612381565b90505b92915050565b6000828152600760209081526040808320815160e08101835281546001600160a01b0380821660a084019081526001600160601b03600160a01b909304831660c08501528352600184015491821695830195909552600160601b900490931691830191909152600201546001600160801b038082166060840152600160801b90910416608082015261062f9083426117a9565b6000838152600760209081526040808320815160e08101835281546001600160a01b0380821660a084019081526001600160601b03600160a01b909304831660c08501528352600184015491821695830195909552600160601b900490931691830191909152600201546001600160801b038082166060840152600160801b90910416608082015261075e9084846117a9565b90505b9392505050565b60006107ac86868686868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061184e92505050565b9695505050505050565b6000818152600760209081526040808320815160e08101835281546001600160a01b0380821660a084018181526001600160601b03600160a01b909404841660c08601528452600185015492831696840196909652600160601b9091041692810192909252600201546001600160801b038082166060840152600160801b9091041660808201528291829182916108556002546001600160a01b031690565b60208301516005544290610872906001600160601b038416612395565b1161087e576000610884565b83608001515b92999198506001600160601b031696506001600160801b03909116945092505050565b600881815481106108b757600080fd5b600091825260209091200154905081565b60006108d2611c3a565b60006108e66002546001600160a01b031690565b90506001600160a01b038416158015906109125750806001600160a01b0316846001600160a01b031614155b6109375760405162461bcd60e51b815260040161092e906123a8565b60405180910390fd5b6001600160a01b0383161580159061095857506001600160a01b0383163014155b61098f5760405162461bcd60e51b81526020600482015260086024820152673932b1b2b4bb32b960c11b604482015260640161092e565b6000846001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f391906123ce565b60ff1690506012811115610a405760405162461bcd60e51b8152602060048201526014602482015273756e737570706f7274656420646563696d616c7360601b604482015260640161092e565b610a498561055b565b6000818152600760205260409020549093506001600160a01b031615610aa35760405162461bcd60e51b815260206004820152600f60248201526e185b1c9958591e48195b98589b1959608a1b604482015260640161092e565b6040518060400160405280866001600160a01b0316815260200182600a610aca91906124d5565b610adc90670de0b6b3a7640000612381565b6001600160601b039081169091526000858152600760209081526040808320855195909201518416600160a01b026001600160a01b03958616178255600191820180548a8716600160601b029516949094179093556008805491820181559091527ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee30185905551309184811691908816907fa9b5c38938a08935cb778e3d605a3597b90626217d89dd3b81b2842afd44d44990610b9c9088815260200190565b60405180910390a4505092915050565b60065460008281526007602052604081206001015490914291610bd891906001600160601b0316612395565b1115610be657506000919050565b6040805160a0810182526003546001600160a01b038116825260ff600160a01b820481161580156020850152600160a81b83048216151594840194909452600160b01b8204811615156060840152600160b81b909104161515608082015290610cc6578051600084815260076020526040908190205490516325654a4160e11b81526001600160a01b039182166004820152911690634aca9482906024015b602060405180830381865afa158015610ca2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076191906124e1565b600083815260076020526040908190205490516370a0823160e01b81523060048201526001600160a01b03909116906370a0823190602401610c85565b600061063282336108c8565b610d17611c3a565b6003546001600160a01b031680610d5e5760405162461bcd60e51b815260206004820152600b60248201526a1b9bc81a1bdbdac81cd95d60aa1b604482015260640161092e565b6040805160a0810182526001600160a01b039290921680835295151560208301819052941515908201819052921515606082018190529115156080909101819052600380546001600160a81b031916909517600160a01b9094029390931761ffff60a81b1916600160a81b90920260ff60b01b191691909117600160b01b9091021760ff60b81b1916600160b81b909102179055565b6000610dfe611c84565b6000828152600760205260409020546001600160a01b031680610e515760405162461bcd60e51b815260206004820152600b60248201526a1b9bdd08195b98589b195960aa1b604482015260640161092e565b600654600084815260076020526040902060010154610e7991906001600160601b0316612395565b4211610eb25760405162461bcd60e51b81526020600482015260086024820152673a37b79039b7b7b760c11b604482015260640161092e565b6040805160a0810182526003546001600160a01b038116825260ff600160a01b8204811615156020840152600160a81b8204811615801594840194909452600160b01b8204811615156060840152600160b81b909104161515608082015290610f8b578051604051636c9d273b60e01b81526001600160a01b03848116600483015290911690636c9d273b906024016020604051808303816000875af1158015610f60573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f8491906124e1565b9250610ff6565b6040516370a0823160e01b81523060048201526001600160a01b038316906370a0823190602401602060405180830381865afa158015610fcf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ff391906124e1565b92505b826000036110385760405162461bcd60e51b815260206004820152600f60248201526e6e6f7468696e6720746f206b69636b60881b604482015260640161092e565b6000848152600760209081526040918290206001810180546bffffffffffffffffffffffff1916426001600160601b03161790556001600160801b038616600160801b81021760029091015581518681529081018590527fef61879be5c5afaf06f105600956f332a8a4427339f9eeb6371de03b7e7eb604910160405180910390a150506110c560018055565b919050565b600554156111085760405162461bcd60e51b815260206004820152600b60248201526a1a5b9a5d1a585b1a5e995960aa1b604482015260640161092e565b6001600160a01b03861661112e5760405162461bcd60e51b815260040161092e906123a8565b826000036111675760405162461bcd60e51b81526020600482015260066024820152650d8cadccee8d60d31b604482015260640161092e565b8183106111a15760405162461bcd60e51b815260206004820152600860248201526731b7b7b63237bbb760c11b604482015260640161092e565b806000036111e25760405162461bcd60e51b815260206004820152600e60248201526d7374617274696e6720707269636560901b604482015260640161092e565b6000866001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015611222573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061124691906123ce565b60ff16905060128111156112935760405162461bcd60e51b8152602060048201526014602482015273756e737570706f7274656420646563696d616c7360601b604482015260640161092e565b6040518060400160405280886001600160a01b0316815260200182600a6112ba91906124d5565b6112cc90670de0b6b3a7640000612381565b6001600160601b03908116909152815160209092015116600160a01b026001600160a01b0391821617600255861615611365576040805160a0810182526001600160a01b03881680825260016020830181905292820183905260608201839052608090910191909152600380546201010160a81b62ffffff60a81b196001600160a81b0319909216909317600160a01b17169190911790555b50600080546001600160a01b0319166001600160a01b0395909516949094179093556005919091556006556004555050565b600061063282426105c1565b600061062f838333845b6040519080825280601f01601f1916602001820160405280156113d7576020820181803683370190505b5061184e565b60006106328260001933846113ad565b6113f5611c3a565b6001600160a01b03811661141b5760405162461bcd60e51b815260040161092e906123a8565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f5f56bee8cffbe9a78652a74a60705edede02af10b0bbb888ca44b79a0d42ce809190a35050565b600061075e848484846113ad565b611484816000611487565b50565b61148f611c3a565b600061149a8361055b565b6000818152600760205260409020549091506001600160a01b03166114ef5760405162461bcd60e51b815260206004820152600b60248201526a1b9bdd08195b98589b195960aa1b604482015260640161092e565b60008181526007602090815260408083208381556001810184905560020183905560088054825181850281018501909352808352919290919083018282801561155757602002820191906000526020600020905b815481526020019060010190808311611543575b5050505050905081818481518110611571576115716124fa565b6020026020010151146115c45760005b81518110156115c2578282828151811061159d5761159d6124fa565b6020026020010151036115b2578093506115c2565b6115bb81612510565b9050611581565b505b600181516115d29190612529565b8310156116365780600182516115e89190612529565b815181106115f8576115f86124fa565b6020026020010151818481518110611612576116126124fa565b6020026020010181815250508060089080519060200190611634929190612042565b505b60088054806116475761164761253c565b60019003818190600052602060002001600090559055306001600160a01b03166116796002546001600160a01b031690565b6001600160a01b0316856001600160a01b03167f91a8bc2b8f0145a75c0dbdeb484f5012b1c37a5bf0ced2448fe0a5eb157f21ba856040516116bd91815260200190565b60405180910390a450505050565b6000826000036116dd57506000610761565b60006116e98584612529565b90506005548111156116ff576000915050610761565b600061170d610e1083612381565b6b033b2e3c9fd0803ce8000000901c9050600061174d6b0331adfc6b81cf95c39de3b1603c61173e610e1087612552565b6117489190612381565b611cdd565b90506000611770600454670de0b6b3a764000061176a9190612566565b88611d56565b90506b033b2e3c9fd0803ce80000006117898484611d80565b6117939083612566565b61179d9190612381565b98975050505050505050565b6000600260000160149054906101000a90046001600160601b03166001600160601b0316670de0b6b3a764000061181786602001516001600160601b03168760000151602001516001600160601b031688606001516118089190612340565b6001600160801b0316866116cb565b865160200151611830906001600160601b031687612566565b61183a9190612566565b6118449190612381565b61075e9190612381565b6000611858611c84565b600085815260076020908152604091829020825160e08101845281546001600160a01b0380821660a084019081526001600160601b03600160a01b909304831660c085015283526001840154918216948301859052600160601b9091041693810193909352600201546001600160801b038082166060850152600160801b90910416608083015260055442916118ee9190612395565b10156119295760405162461bcd60e51b815260206004820152600a6024820152691b9bdd081ada58dad95960b21b604482015260640161092e565b8481608001516001600160801b0316116119505780608001516001600160801b0316611952565b845b915060006119618284426117a9565b9050806000036119a15760405162461bcd60e51b815260206004820152600b60248201526a1e995c9bc81b995959195960aa1b604482015260640161092e565b60808083015160008981526007602090815260409182902060020180546001600160801b03948516899003808616600160801b0291909516179055815160a0810183526003546001600160a01b038116825260ff600160a01b82048116151593830193909352600160a81b81048316151593820193909352600160b01b830482161580156060830152600160b81b909304909116151593810193909352909190611ab4578051845151604051633d9f5c6d60e11b81526001600160a01b0391821660048201526024810188905260448101869052911690637b3eb8da90606401600060405180830381600087803b158015611a9b57600080fd5b505af1158015611aaf573d6000803e3d6000fd5b505050505b835151611acb906001600160a01b03168887611da4565b855115611b3957604051634d2421a160e11b81526001600160a01b03881690639a48434290611b06908c9033908a9089908d906004016125cd565b600060405180830381600087803b158015611b2057600080fd5b505af1158015611b34573d6000803e3d6000fd5b505050505b6000611b4d6002546001600160a01b031690565b6040860151909150611b6c906001600160a01b03831690339087611e0c565b816080015115611be35781516040516316e3592d60e11b81526001600160a01b038381166004830152602482018990526044820187905290911690632dc6b25a90606401600060405180830381600087803b158015611bca57600080fd5b505af1158015611bde573d6000803e3d6000fd5b505050505b604080518b8152602081018890529081018490527fa12bdb0d0ef60c3f00e0eed0f059fe52fc1d44dfc28fc78783307c773e5258869060600160405180910390a15050505050611c3260018055565b949350505050565b6000546001600160a01b03163314611c825760405162461bcd60e51b815260206004820152600b60248201526a21676f7665726e616e636560a81b604482015260640161092e565b565b600260015403611cd65760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640161092e565b6002600155565b6000611cea600283612552565b600003611d03576b033b2e3c9fd0803ce8000000611d05565b825b9050611d12600283612381565b91505b811561063257611d258384611d80565b9250611d32600283612552565b15611d4457611d418184611d80565b90505b611d4f600283612381565b9150611d15565b600081611d64600282612381565b611d76670de0b6b3a764000086612566565b6106259190612395565b60006b033b2e3c9fd0803ce8000000611d9a600282612381565b611d768486612566565b6040516001600160a01b038316602482015260448101829052611e0790849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611e4a565b505050565b6040516001600160a01b0380851660248301528316604482015260648101829052611e449085906323b872dd60e01b90608401611dd0565b50505050565b6000611e9f826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611f1f9092919063ffffffff16565b9050805160001480611ec0575080806020019051810190611ec09190612600565b611e075760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b606482015260840161092e565b606061075e848460008585600080866001600160a01b03168587604051611f46919061261d565b60006040518083038185875af1925050503d8060008114611f83576040519150601f19603f3d011682016040523d82523d6000602084013e611f88565b606091505b5091509150611f9987838387611fa4565b979650505050505050565b6060831561201357825160000361200c576001600160a01b0385163b61200c5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161092e565b5081611c32565b611c3283838151156120285781518083602001fd5b8060405162461bcd60e51b815260040161092e9190612639565b82805482825590600052602060002090810192821561207d579160200282015b8281111561207d578251825591602001919060010190612062565b5061208992915061208d565b5090565b5b80821115612089576000815560010161208e565b80356001600160a01b03811681146110c557600080fd5b6000602082840312156120cb57600080fd5b61062f826120a2565b600080604083850312156120e757600080fd5b50508035926020909101359150565b60008060006060848603121561210b57600080fd5b505081359360208301359350604090920135919050565b60008060008060006080868803121561213a57600080fd5b8535945060208601359350612151604087016120a2565b9250606086013567ffffffffffffffff8082111561216e57600080fd5b818801915088601f83011261218257600080fd5b81358181111561219157600080fd5b8960208285010111156121a357600080fd5b9699959850939650602001949392505050565b6000602082840312156121c857600080fd5b5035919050565b600080604083850312156121e257600080fd5b6121eb836120a2565b91506121f9602084016120a2565b90509250929050565b801515811461148457600080fd5b6000806000806080858703121561222657600080fd5b843561223181612202565b9350602085013561224181612202565b9250604085013561225181612202565b9150606085013561226181612202565b939692955090935050565b60008060008060008060c0878903121561228557600080fd5b61228e876120a2565b955061229c602088016120a2565b94506122aa604088016120a2565b9350606087013592506080870135915060a087013590509295509295509295565b6000806000606084860312156122e057600080fd5b83359250602084013591506122f7604085016120a2565b90509250925092565b6000806040838503121561231357600080fd5b61231c836120a2565b946020939093013593505050565b634e487b7160e01b600052601160045260246000fd5b6001600160801b038181168382160280821691908281146123635761236361232a565b505092915050565b634e487b7160e01b600052601260045260246000fd5b6000826123905761239061236b565b500490565b808201808211156106325761063261232a565b6020808252600c908201526b5a45524f204144445245535360a01b604082015260600190565b6000602082840312156123e057600080fd5b815160ff8116811461076157600080fd5b600181815b8085111561242c5781600019048211156124125761241261232a565b8085161561241f57918102915b93841c93908002906123f6565b509250929050565b60008261244357506001610632565b8161245057506000610632565b816001811461246657600281146124705761248c565b6001915050610632565b60ff8411156124815761248161232a565b50506001821b610632565b5060208310610133831016604e8410600b84101617156124af575081810a610632565b6124b983836123f1565b80600019048211156124cd576124cd61232a565b029392505050565b600061062f8383612434565b6000602082840312156124f357600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b6000600182016125225761252261232a565b5060010190565b818103818111156106325761063261232a565b634e487b7160e01b600052603160045260246000fd5b6000826125615761256161236b565b500690565b80820281158282048414176106325761063261232a565b60005b83811015612598578181015183820152602001612580565b50506000910152565b600081518084526125b981602086016020860161257d565b601f01601f19169290920160200192915050565b85815260018060a01b038516602082015283604082015282606082015260a060808201526000611f9960a08301846125a1565b60006020828403121561261257600080fd5b815161076181612202565b6000825161262f81846020870161257d565b9190910192915050565b60208152600061062f60208301846125a156fea26469706673582212205c7d8975d468206cce82a7bf930d55d1735319deed9140f2ed0162f43314659764736f6c63430008120033');
        vm.store(0xE6aB098E8582178A76DC80d55ca304d1Dec11AD8, bytes32(0), bytes32(uint256(uint160(0x12e3250114a4a8439f8feDcCD0CfCc41a4e7b572))));
        // create managed veNFT
        vm.prank(escrow.allowedManager());
        mTokenId = escrow.createManagedLockFor(address(owner));
        lockedManagedReward = LockedManagedReward(escrow.managedToLocked(mTokenId));
        freeManagedReward = FreeManagedReward(escrow.managedToFree(mTokenId));

        vm.startPrank(address(owner));

        // Create normal veNFT and deposit into managed
        deal(address(VELO), address(owner), TOKEN_1);
        VELO.approve(address(escrow), TOKEN_1);
        tokenId = escrow.createLock(TOKEN_1, MAXTIME);

        skipToNextEpoch(1 hours + 1);
        voter.depositManaged(tokenId, mTokenId);

        // Create auto compounder
        optimizer = new Optimizer(
            address(USDC),
            address(WETH),
            address(FRAX), // OP
            address(VELO),
            address(factory),
            address(router)
        );
        optimizerRegistry = new Registry(new address[](0));
        optimizerRegistry.approve(address(optimizer));
        keeperRegistry = new Registry(new address[](0));
        auctionAutoCompounderFactory = new AuctionAutoCompounderFactory(
            address(voter),
            address(router),
            address(keeperRegistry),
            address(optimizerRegistry),
            address(optimizer),
            new address[](0)
        );
        escrow.approve(address(auctionAutoCompounderFactory), mTokenId);
        auctionAutoCompounder = AuctionAutoCompounder(auctionAutoCompounderFactory.createRelay(address(owner), mTokenId, "", new bytes(0)));

        skipToNextEpoch(1 hours + 1);

        vm.stopPrank();

        // Add the owner as a keeper
        vm.prank(escrow.team());
        keeperRegistry.approve(address(owner));

        // Create a VELO pool for USDC, WETH, and FRAX (seen as OP in Optimizer)
        deal(address(VELO), address(owner), TOKEN_100K * 3);
        deal(address(WETH), address(owner), TOKEN_1 * 3);

        // @dev these pools have a higher VELO price value than v1 pools
        _createPoolAndSimulateSwaps(address(USDC), address(VELO), USDC_1, TOKEN_1, address(USDC), 10, 3);
        _createPoolAndSimulateSwaps(address(WETH), address(VELO), TOKEN_1, TOKEN_100K, address(VELO), 1e6, 3);
        _createPoolAndSimulateSwaps(address(FRAX), address(VELO), TOKEN_1, TOKEN_1, address(VELO), 1e6, 3);
        _createPoolAndSimulateSwaps(address(FRAX), address(DAI), TOKEN_1, TOKEN_1, address(FRAX), 1e6, 3);

        // skip to last day where claiming becomes public
        skipToNextEpoch(6 days + 1);
    }

    function _createPoolAndSimulateSwaps(
        address token1,
        address token2,
        uint256 liquidity1,
        uint256 liquidity2,
        address tokenIn,
        uint256 amountSwapped,
        uint256 numSwapped
    ) internal {
        address tokenOut = tokenIn == token1 ? token2 : token1;
        _addLiquidityToPool(address(owner), address(router), token1, token2, false, liquidity1, liquidity2);

        IRouter.Route[] memory routes = new IRouter.Route[](1);

        // for every hour, simulate a swap to add an observation
        for (uint256 i = 0; i < numSwapped; i++) {
            skipAndRoll(1 hours);
            routes[0] = IRouter.Route(tokenIn, tokenOut, false, address(0));

            IERC20(tokenIn).approve(address(router), amountSwapped);
            router.swapExactTokensForTokens(amountSwapped, 0, routes, address(owner), block.timestamp);
        }
    }

    function testKeeperLastRunSetup() public {
        assertEq(auctionAutoCompounder.keeperLastRun(), 0);
    }

    function testOptimizerSetup() public {
        assertFalse(address(auctionAutoCompounder.optimizer()) == address(0));
    }

    function testManagedTokenID() public {
        assertEq(auctionAutoCompounder.mTokenId(), mTokenId);
        assertEq(escrow.ownerOf(mTokenId), address(auctionAutoCompounder));
        assertTrue(escrow.escrowType(mTokenId) == IVotingEscrow.EscrowType.MANAGED);
    }

    function testCannotInitializeIfAlreadyInitialized() external {
        vm.expectRevert("Initializable: contract is already initialized");
        auctionAutoCompounder.initialize(1);
    }

    function testCannotInitializeTokenNotOwned() external {
        AuctionAutoCompounder comp = new AuctionAutoCompounder(
            address(voter),
            address(owner),
            "",
            address(router),
            address(optimizer),
            address(auctionAutoCompounderFactory)
        );
        uint256 _mTokenId = escrow.createManagedLockFor(address(owner));
        vm.prank(escrow.allowedManager());
        vm.expectRevert(IRelay.ManagedTokenNotOwned.selector);
        comp.initialize(_mTokenId);
    }

    function testCannotInitializeTokenNotManaged() external {
        AuctionAutoCompounder comp = new AuctionAutoCompounder(
            address(voter),
            address(owner),
            "",
            address(router),
            address(optimizer),
            address(auctionAutoCompounderFactory)
        );
        vm.prank(escrow.allowedManager());
        vm.expectRevert(IRelay.TokenIdNotManaged.selector);
        comp.initialize(2);
    }

    function testCannotSwapIfNoRouteFound() public {
        // Create a new pool with liquidity that doesn't swap into VELO
        IERC20 tokenA = IERC20(new MockERC20("Token A", "A", 18));
        IERC20 tokenB = IERC20(new MockERC20("Token B", "B", 18));
        deal(address(tokenA), address(owner), TOKEN_1 * 2, true);
        deal(address(tokenB), address(owner), TOKEN_1 * 2, true);
        _createPoolAndSimulateSwaps(address(tokenA), address(tokenB), TOKEN_1, TOKEN_1, address(tokenA), 1e6, 3);

        // give rewards to the auctionAutoCompounder
        deal(address(tokenA), address(auctionAutoCompounder), 1e6);

        // Attempt swapping into VELO - should revert
        address tokenToSwap = address(tokenA);
        uint256 slippage = 0;
        IRouter.Route[] memory optionalRoute = new IRouter.Route[](0);
        vm.expectRevert(IAutoCompounder.NoRouteFound.selector);
        auctionAutoCompounder.swapTokenToVELOWithOptionalRoute(tokenToSwap, slippage, optionalRoute);

        // Cannot swap for a token that doesn't have a pool
        IERC20 tokenC = IERC20(new MockERC20("Token C", "C", 18));
        deal(address(tokenC), address(auctionAutoCompounder), 1e6);

        tokenToSwap = address(tokenC);

        // Attempt swapping into VELO - should revert
        vm.expectRevert(IAutoCompounder.NoRouteFound.selector);
        auctionAutoCompounder.swapTokenToVELOWithOptionalRoute(tokenToSwap, slippage, optionalRoute);
    }

    function testSwapToVELOAndCompoundIfCompoundRewardAmount() public {
        // Deal USDC, FRAX, and DAI to autocompounder to simulate earning bribes
        // NOTE: the low amount of bribe rewards leads to receiving 1% of the reward amount
        deal(address(USDC), address(auctionAutoCompounder), 1e2);
        deal(address(FRAX), address(auctionAutoCompounder), 1e6);
        deal(address(DAI), address(auctionAutoCompounder), 1e6);

        uint256 balanceNFTBefore = escrow.balanceOfNFT(mTokenId);
        uint256 balanceVELOBefore = VELO.balanceOf(address(owner4));

        // Random user calls swapToVELO() for each token and then claims reward
        vm.startPrank(address(owner4));
        uint256 slippage = 500;
        IRouter.Route[] memory optionalRoute = new IRouter.Route[](0);
        bytes[] memory calls = new bytes[](4);
        calls[0] = abi.encodeCall(
            auctionAutoCompounder.swapTokenToVELOWithOptionalRoute,
            (address(USDC), slippage, optionalRoute)
        );
        calls[1] = abi.encodeCall(
            auctionAutoCompounder.swapTokenToVELOWithOptionalRoute,
            (address(FRAX), slippage, optionalRoute)
        );
        calls[2] = abi.encodeCall(
            auctionAutoCompounder.swapTokenToVELOWithOptionalRoute,
            (address(DAI), slippage, optionalRoute)
        );
        calls[3] = abi.encodeWithSelector(auctionAutoCompounder.rewardAndCompound.selector);
        auctionAutoCompounder.multicall(calls);

        // USDC and FRAX converted even though they already have a direct pair to VELO
        // DAI converted without a direct pair to VELO
        assertEq(USDC.balanceOf(address(auctionAutoCompounder)), 0);
        assertEq(FRAX.balanceOf(address(auctionAutoCompounder)), 0);
        assertEq(DAI.balanceOf(address(auctionAutoCompounder)), 0);
        assertEq(VELO.balanceOf(address(auctionAutoCompounder)), 0);

        uint256 rewardAmountToNFT = escrow.balanceOfNFT(mTokenId) - balanceNFTBefore;
        uint256 rewardAmountToCaller = VELO.balanceOf(address(owner4)) - balanceVELOBefore;

        assertGt(rewardAmountToNFT, 0);
        assertGt(rewardAmountToCaller, 0);
        assertLt(rewardAmountToCaller, auctionAutoCompounderFactory.rewardAmount());

        // total reward is 100x what caller received - as caller received 1% the total reward
        assertEq((rewardAmountToNFT + rewardAmountToCaller) / 100, rewardAmountToCaller);
    }

    function testSwapToVELOAndCompoundIfFactoryRewardAmount() public {
        // Adjust the factory reward rate to a lower VELO to trigger the rewardAmount.
        // NOTE: this will not be needed in prod as more than 0.00000001 DAI etc. will
        // be compounded at one time
        vm.prank(escrow.team());
        auctionAutoCompounderFactory.setRewardAmount(1e17);

        // Deal USDC, WETH, and DAI to autocompounder to simulate earning bribe rewards
        // NOTE; the difference here is WETH for a higher amount of VELO swapped
        deal(address(USDC), address(auctionAutoCompounder), 1e3);
        deal(address(WETH), address(auctionAutoCompounder), 1e15);
        deal(address(DAI), address(auctionAutoCompounder), 1e6);

        uint256 balanceVELOCallerBefore = VELO.balanceOf(address(owner4));
        uint256 balanceNFTBefore = escrow.balanceOfNFT(mTokenId);

        // Random user calls swapToVELO() for each token and then claims reward
        vm.startPrank(address(owner4));
        uint256 slippage = 500;
        IRouter.Route[] memory optionalRoute = new IRouter.Route[](0);
        bytes[] memory calls = new bytes[](4);
        calls[0] = abi.encodeCall(
            auctionAutoCompounder.swapTokenToVELOWithOptionalRoute,
            (address(USDC), slippage, optionalRoute)
        );
        calls[1] = abi.encodeCall(
            auctionAutoCompounder.swapTokenToVELOWithOptionalRoute,
            (address(WETH), slippage, optionalRoute)
        );
        calls[2] = abi.encodeCall(
            auctionAutoCompounder.swapTokenToVELOWithOptionalRoute,
            (address(DAI), slippage, optionalRoute)
        );
        calls[3] = abi.encodeWithSelector(auctionAutoCompounder.rewardAndCompound.selector);
        auctionAutoCompounder.multicall(calls);

        // USDC and FRAX converted even though they already have a direct pair to VELO
        // DAI converted without a direct pair to VELO
        assertEq(USDC.balanceOf(address(auctionAutoCompounder)), 0);
        assertEq(WETH.balanceOf(address(auctionAutoCompounder)), 0);
        assertEq(DAI.balanceOf(address(auctionAutoCompounder)), 0);
        assertEq(VELO.balanceOf(address(auctionAutoCompounder)), 0);

        // Compounded into the mTokenId and caller has received a refund equal to the factory rewardAmount
        assertEq(VELO.balanceOf(address(owner4)), balanceVELOCallerBefore + auctionAutoCompounderFactory.rewardAmount());
        assertGt(escrow.balanceOfNFT(mTokenId), balanceNFTBefore);
    }

    function testClaimAndMulticallClaimRebaseOnly() public {
        address[] memory pools = new address[](2);
        pools[0] = address(pool);
        pools[1] = address(pool2);
        uint256[] memory weights = new uint256[](2);
        weights[0] = 1;
        weights[1] = 1;

        auctionAutoCompounder.vote(pools, weights);

        skipToNextEpoch(6 days + 1);
        minter.updatePeriod();

        uint256 claimable = distributor.claimable(mTokenId);
        assertGt(distributor.claimable(mTokenId), 0);

        uint256 balanceNFTBefore = escrow.balanceOfNFT(mTokenId);
        bytes[] memory calls = new bytes[](1);
        calls[0] = abi.encodeCall(auctionAutoCompounder.claimBribes, (bribes, tokensToClaim));
        auctionAutoCompounder.multicall(calls);
        assertEq(escrow.balanceOfNFT(mTokenId), balanceNFTBefore + claimable);
    }

    function testRewardAndCompoundOnlyExistingVELOBalance() public {
        deal(address(VELO), address(auctionAutoCompounder), 1e18);

        uint256 balanceNFTBefore = escrow.balanceOfNFT(mTokenId);

        vm.prank(address(owner2));
        auctionAutoCompounder.rewardAndCompound();

        // mTokenId has received the full VELO balance from the auctionAutoCompounder - meaning
        // the VELO has been directly compounded without a swap (minus fee)
        assertEq(escrow.balanceOfNFT(mTokenId), balanceNFTBefore + 1e18 - 1e16);
        assertEq(VELO.balanceOf(address(auctionAutoCompounder)), 0);
    }

    function testSwapTokenToVELOWithOptionalRouteAndCompoundIfBetterRate() public {
        // create a new pool with
        //  - liquidity of the token swapped to the mock token
        //  - liquidity of the mock token to VELO to return a lot of VELO
        // And add mock token as a high liquidity token
        MockERC20 mockToken = new MockERC20("Mock Token", "MOCK", 18);
        auctionAutoCompounderFactory.addHighLiquidityToken(address(mockToken));
        deal(address(mockToken), address(owner), TOKEN_1 * 3);
        deal(address(VELO), address(owner), TOKEN_100M + TOKEN_1 * 3);

        _createPoolAndSimulateSwaps(address(mockToken), address(FRAX), TOKEN_1, TOKEN_1, address(FRAX), 1e6, 3);
        _createPoolAndSimulateSwaps(address(mockToken), address(VELO), TOKEN_1, TOKEN_100M, address(VELO), TOKEN_1, 3);

        // simulate reward
        deal(address(FRAX), address(auctionAutoCompounder), 1e6);

        IRouter.Route[] memory optionalRoute = new IRouter.Route[](2);
        optionalRoute[0] = IRouter.Route(address(FRAX), address(mockToken), false, address(0));
        optionalRoute[1] = IRouter.Route(address(mockToken), address(VELO), false, address(0));

        address tokenToSwap = address(FRAX);
        uint256 slippage = 500;

        uint256[] memory amountsOut = router.getAmountsOut(1e6, optionalRoute);
        uint256 amountOut = amountsOut[amountsOut.length - 1];
        uint256 balanceOwnerBefore = VELO.balanceOf(address(owner));
        uint256 balanceNFTBefore = escrow.balanceOfNFT(mTokenId);

        bytes[] memory calls = new bytes[](2);
        calls[0] = abi.encodeCall(
            auctionAutoCompounder.swapTokenToVELOWithOptionalRoute,
            (tokenToSwap, slippage, optionalRoute)
        );
        calls[1] = abi.encodeWithSelector(auctionAutoCompounder.rewardAndCompound.selector);
        auctionAutoCompounder.multicall(calls);

        // validate the amount received by caller and balance increased to (m)veNFT equal
        // the amount out of the optionalRoute over the Optimizer suggested route
        uint256 balanceOwnerDelta = VELO.balanceOf(address(owner)) - balanceOwnerBefore;
        uint256 balanceNFTDelta = escrow.balanceOfNFT(mTokenId) - balanceNFTBefore;
        assertEq(balanceOwnerDelta + balanceNFTDelta, amountOut);
    }

    function testSwapTokenToVELOWithOptionalRouteAndCompoundIfBetterRateFromHighLiquidityToken() public {
        // create a new pool with
        //  - liquidity of the token swapped to the mock token
        //  - liquidity of the mock token to VELO to return a lot of VELO
        // Add mock token and token swapping from as high liquidity tokens
        MockERC20 mockToken = new MockERC20("Mock Token", "MOCK", 18);
        auctionAutoCompounderFactory.addHighLiquidityToken(address(mockToken));
        auctionAutoCompounderFactory.addHighLiquidityToken(address(FRAX));
        deal(address(mockToken), address(owner), TOKEN_1 * 3);
        deal(address(VELO), address(owner), TOKEN_100M + TOKEN_1 * 3);

        _createPoolAndSimulateSwaps(address(mockToken), address(FRAX), TOKEN_1, TOKEN_1, address(FRAX), 1e6, 3);
        _createPoolAndSimulateSwaps(address(mockToken), address(VELO), TOKEN_1, TOKEN_100M, address(VELO), TOKEN_1, 3);

        // simulate reward
        deal(address(FRAX), address(auctionAutoCompounder), 1e6);

        address tokenToSwap = address(FRAX);
        uint256 slippage = 500;
        IRouter.Route[] memory optionalRoute = new IRouter.Route[](2);
        optionalRoute[0] = IRouter.Route(address(FRAX), address(mockToken), false, address(0));
        optionalRoute[1] = IRouter.Route(address(mockToken), address(VELO), false, address(0));

        uint256[] memory amountsOut = router.getAmountsOut(1e6, optionalRoute);
        uint256 amountOut = amountsOut[amountsOut.length - 1];
        uint256 balanceOwnerBefore = VELO.balanceOf(address(owner));
        uint256 balanceNFTBefore = escrow.balanceOfNFT(mTokenId);

        bytes[] memory calls = new bytes[](2);
        calls[0] = abi.encodeCall(
            auctionAutoCompounder.swapTokenToVELOWithOptionalRoute,
            (tokenToSwap, slippage, optionalRoute)
        );
        calls[1] = abi.encodeWithSelector(auctionAutoCompounder.rewardAndCompound.selector);
        auctionAutoCompounder.multicall(calls);

        // validate the amount received by caller and balance increased to (m)veNFT equal
        // the amount out of the optionalRoute over the Optimizer suggested route
        uint256 balanceOwnerDelta = VELO.balanceOf(address(owner)) - balanceOwnerBefore;
        uint256 balanceNFTDelta = escrow.balanceOfNFT(mTokenId) - balanceNFTBefore;
        assertEq(balanceOwnerDelta + balanceNFTDelta, amountOut);
    }

    function testCannotSwapTokenToVELOWithOptionalRouteIfDoesNotUseHighLiquidityToken() public {
        // create a new pool with
        //  - liquidity of the token swapped to the mock token
        //  - liquidity of the mock token to VELO to return a lot of VELO
        // Mock Token is not added as a high liquidity token, so will revert
        MockERC20 mockToken = new MockERC20("Mock Token", "MOCK", 18);
        deal(address(mockToken), address(owner), TOKEN_1 * 3);
        deal(address(VELO), address(owner), TOKEN_100M + TOKEN_1 * 3);

        _createPoolAndSimulateSwaps(address(mockToken), address(FRAX), TOKEN_1, TOKEN_1, address(FRAX), 1e6, 3);
        _createPoolAndSimulateSwaps(address(mockToken), address(VELO), TOKEN_1, TOKEN_100M, address(VELO), TOKEN_1, 3);

        // simulate reward
        deal(address(FRAX), address(auctionAutoCompounder), 1e6);

        address tokenToSwap = address(FRAX);
        uint256 slippage = 500;
        IRouter.Route[] memory optionalRoute = new IRouter.Route[](2);
        optionalRoute[0] = IRouter.Route(address(FRAX), address(mockToken), false, address(0));
        optionalRoute[1] = IRouter.Route(address(mockToken), address(VELO), false, address(0));

        vm.expectRevert(IAutoCompounder.NotHighLiquidityToken.selector);
        auctionAutoCompounder.swapTokenToVELOWithOptionalRoute(tokenToSwap, slippage, optionalRoute);
    }

    function testSwapTokenToVELOWithOptionalRouteAndCompoundIfOnlyRoute() public {
        // create a new pool with
        //  - liquidity of the mock token to VELO
        // For a token that does NOT have a route supported by Optimizer
        MockERC20 mockToken = new MockERC20("Mock Token", "MOCK", 18);
        deal(address(mockToken), address(owner), TOKEN_1 * 3);
        deal(address(VELO), address(owner), TOKEN_100M + TOKEN_1 * 3);

        _createPoolAndSimulateSwaps(address(mockToken), address(VELO), TOKEN_1, TOKEN_100M, address(VELO), TOKEN_1, 3);

        // simulate reward
        deal(address(mockToken), address(auctionAutoCompounder), 1e6);

        address tokenToSwap = address(mockToken);
        uint256 slippage = 500;
        IRouter.Route[] memory optionalRoute = new IRouter.Route[](1);
        optionalRoute[0] = IRouter.Route(address(mockToken), address(VELO), false, address(0));

        uint256[] memory amountsOut = router.getAmountsOut(1e6, optionalRoute);
        uint256 amountOut = amountsOut[amountsOut.length - 1];
        uint256 balanceOwnerBefore = VELO.balanceOf(address(owner));
        uint256 balanceNFTBefore = escrow.balanceOfNFT(mTokenId);

        bytes[] memory calls = new bytes[](2);
        calls[0] = abi.encodeCall(
            auctionAutoCompounder.swapTokenToVELOWithOptionalRoute,
            (tokenToSwap, slippage, optionalRoute)
        );
        calls[1] = abi.encodeWithSelector(auctionAutoCompounder.rewardAndCompound.selector);
        auctionAutoCompounder.multicall(calls);

        // validate the amount received by caller and balance increased to (m)veNFT equal
        // the amount out of the optionalRoute
        uint256 balanceOwnerDelta = VELO.balanceOf(address(owner)) - balanceOwnerBefore;
        uint256 balanceNFTDelta = escrow.balanceOfNFT(mTokenId) - balanceNFTBefore;
        assertEq(balanceOwnerDelta + balanceNFTDelta, amountOut);
    }

    function testIncreaseAmount() public {
        uint256 amount = TOKEN_1;
        deal(address(VELO), address(owner), amount);
        VELO.approve(address(auctionAutoCompounder), amount);

        uint256 balanceBefore = escrow.balanceOfNFT(mTokenId);
        uint256 supplyBefore = escrow.totalSupply();

        auctionAutoCompounder.increaseAmount(amount);

        assertEq(escrow.balanceOfNFT(mTokenId), balanceBefore + amount);
        assertEq(escrow.totalSupply(), supplyBefore + amount);
    }

    function testVote() public {
        address[] memory poolVote = new address[](1);
        uint256[] memory weights = new uint256[](1);
        poolVote[0] = address(pool2);
        weights[0] = 1;

        assertFalse(escrow.voted(mTokenId));

        auctionAutoCompounder.vote(poolVote, weights);

        assertEq(auctionAutoCompounder.keeperLastRun(), block.timestamp);
        assertTrue(escrow.voted(mTokenId));
        assertEq(voter.weights(address(pool2)), escrow.balanceOfNFT(mTokenId));
        assertEq(voter.votes(mTokenId, address(pool2)), escrow.balanceOfNFT(mTokenId));
        assertEq(voter.poolVote(mTokenId, 0), address(pool2));
    }

    function testSwapTokenToVELOAndCompoundKeeper() public {
        address randomKeeper = address(0x123321);
        keeperRegistry.approve(address(randomKeeper));

        uint256 amount = TOKEN_1 / 100;
        deal(address(WETH), address(auctionAutoCompounder), amount);

        uint256 balanceBefore = escrow.balanceOfNFT(mTokenId);
        uint256 veloBalanceBefore = VELO.balanceOf(address(owner));

        IRouter.Route[] memory routes = new IRouter.Route[](1);
        routes[0] = IRouter.Route(address(WETH), address(VELO), false, address(0));
        uint256[] memory amountsOut = router.getAmountsOut(amount, routes);
        uint256 amountOut = amountsOut[amountsOut.length - 1];
        assertGt(amountOut, 0);

        bytes[] memory calls = new bytes[](2);
        uint256 slippage = 500;
        calls[0] = abi.encodeCall(auctionAutoCompounder.swapTokenToVELOWithOptionalRoute, (address(WETH), slippage, routes));
        calls[1] = abi.encodeWithSelector(auctionAutoCompounder.compound.selector);

        vm.startPrank(randomKeeper);
        auctionAutoCompounder.multicall(calls);

        assertEq(auctionAutoCompounder.keeperLastRun(), block.timestamp);
        // no reward given to caller this time- full amount deposited into mTokenId
        assertEq(VELO.balanceOf(address(owner)), veloBalanceBefore);
        assertEq(escrow.balanceOfNFT(mTokenId), balanceBefore + amountOut);
        assertEq(auctionAutoCompounder.amountTokenEarned(VelodromeTimeLibrary.epochStart(block.timestamp)), amountOut);
    }

    function testCannotSwapTokenToVELOKeeperIfFirstHourOfEpoch() public {
        address randomKeeper = address(0x123321);
        keeperRegistry.approve(address(randomKeeper));
        bytes[] memory calls = new bytes[](1);
        IRouter.Route[] memory optionalRoute = new IRouter.Route[](0);
        calls[0] = abi.encodeCall(auctionAutoCompounder.swapTokenToVELOWithOptionalRoute, (address(0), 0, optionalRoute));
        skipToNextEpoch(0);

        vm.startPrank(randomKeeper);
        vm.expectRevert(IAutoCompounder.TooSoon.selector);
        auctionAutoCompounder.swapTokenToVELOWithOptionalRoute(address(0), 0, optionalRoute);
        vm.expectRevert(IRelay.MulticallFailed.selector);
        auctionAutoCompounder.multicall(calls);

        skipToNextEpoch(1 hours - 1);

        vm.startPrank(randomKeeper);
        vm.expectRevert(IAutoCompounder.TooSoon.selector);
        auctionAutoCompounder.swapTokenToVELOWithOptionalRoute(address(0), 0, optionalRoute);
        vm.expectRevert(IRelay.MulticallFailed.selector);
        auctionAutoCompounder.multicall(calls);
    }

    function testCannotSwapTokenToVELOIfNotOnLastDayOfEpoch() external {
        bytes[] memory calls = new bytes[](1);
        IRouter.Route[] memory optionalRoute = new IRouter.Route[](0);
        calls[0] = abi.encodeCall(auctionAutoCompounder.swapTokenToVELOWithOptionalRoute, (address(0), 0, optionalRoute));
        skipToNextEpoch(0);
        // call with non owner nor keeper
        vm.startPrank(address(owner4));
        vm.expectRevert(IAutoCompounder.TooSoon.selector);
        auctionAutoCompounder.swapTokenToVELOWithOptionalRoute(address(0), 0, optionalRoute);
        vm.expectRevert(IRelay.MulticallFailed.selector);
        auctionAutoCompounder.multicall(calls);

        skipToNextEpoch(6 days - 1);
        vm.expectRevert(IAutoCompounder.TooSoon.selector);
        auctionAutoCompounder.swapTokenToVELOWithOptionalRoute(address(0), 0, optionalRoute);
        vm.expectRevert(IRelay.MulticallFailed.selector);
        auctionAutoCompounder.multicall(calls);
    }

    function testCannotRewardAndCompoundIfNotOnLastDayOfEpoch() external {
        skipToNextEpoch(0);
        vm.expectRevert(IAutoCompounder.TooSoon.selector);
        auctionAutoCompounder.rewardAndCompound();

        skipToNextEpoch(6 days - 1);
        vm.expectRevert(IAutoCompounder.TooSoon.selector);
        auctionAutoCompounder.rewardAndCompound();
    }

    function testCannotSwapIfSlippageTooHigh() public {
        address tokenToSwap = address(USDC);
        uint256 slippage = 501;
        IRouter.Route[] memory optionalRoute = new IRouter.Route[](0);
        vm.expectRevert(IAutoCompounder.SlippageTooHigh.selector);
        auctionAutoCompounder.swapTokenToVELOWithOptionalRoute(tokenToSwap, slippage, optionalRoute);
    }

    function testCannotSwapIfAmountInZero() public {
        IRouter.Route[] memory optionalRoute = new IRouter.Route[](0);
        vm.expectRevert(IAutoCompounder.AmountInZero.selector);
        auctionAutoCompounder.swapTokenToVELOWithOptionalRoute(address(USDC), 500, optionalRoute);
    }

    function testHandleRouterApproval() public {
        deal(address(FRAX), address(auctionAutoCompounder), TOKEN_1 / 1000, true);

        // give a fake approval to impersonate a dangling approved amount
        vm.prank(address(auctionAutoCompounder));
        FRAX.approve(address(router), 100);

        // resets and properly approves swap amount
        address tokenToSwap = address(FRAX);
        uint256 slippage = 500;

        IRouter.Route[] memory optionalRoute = new IRouter.Route[](0);
        auctionAutoCompounder.swapTokenToVELOWithOptionalRoute(tokenToSwap, slippage, optionalRoute);
        assertEq(FRAX.allowance(address(auctionAutoCompounder), address(router)), 0);
    }

    // TODO: order tests similar to AuctionAutoCompounder with section titles
    function testCannotSweepAfterFirstDayOfEpoch() public {
        skipToNextEpoch(1 days + 1);
        vm.expectRevert(IAutoCompounder.TooLate.selector);
        auctionAutoCompounder.sweep(tokensToSweep, recipients);
    }

    function testCannotSweepIfNotAdmin() public {
        skipToNextEpoch(1 days - 1);
        bytes memory revertString = bytes(
            "AccessControl: account 0x7d28001937fe8e131f76dae9e9947adedbd0abde is missing role 0x0000000000000000000000000000000000000000000000000000000000000000"
        );
        vm.startPrank(address(owner2));
        vm.expectRevert(revertString);
        auctionAutoCompounder.sweep(tokensToSweep, recipients);
        bytes[] memory calls = new bytes[](1);
        calls[0] = abi.encodeCall(auctionAutoCompounder.sweep, (tokensToSweep, recipients));
        vm.expectRevert(IRelay.MulticallFailed.selector);
        auctionAutoCompounder.multicall(calls);
    }

    function testCannotSweepUnequalLengths() public {
        skipToNextEpoch(1 days - 1);
        recipients.push(address(owner2));
        assertTrue(tokensToSweep.length != recipients.length);
        vm.prank(escrow.team());
        vm.expectRevert(IAutoCompounder.UnequalLengths.selector);
        auctionAutoCompounder.sweep(tokensToSweep, recipients);
    }

    function testCannotSweepHighLiquidityToken() public {
        skipToNextEpoch(1 days - 1);
        tokensToSweep.push(address(USDC));
        recipients.push(address(owner2));
        vm.prank(escrow.team());
        auctionAutoCompounderFactory.addHighLiquidityToken(address(USDC));
        vm.expectRevert(IAutoCompounder.HighLiquidityToken.selector);
        auctionAutoCompounder.sweep(tokensToSweep, recipients);
    }

    function testCannotSweepZeroAddressRecipient() public {
        skipToNextEpoch(1 days - 1);
        tokensToSweep.push(address(USDC));
        recipients.push(address(0));
        vm.prank(escrow.team());
        vm.expectRevert(IRelay.ZeroAddress.selector);
        auctionAutoCompounder.sweep(tokensToSweep, recipients);
    }

    function testSweep() public {
        skipToNextEpoch(1 days - 1);
        tokensToSweep.push(address(USDC));
        recipients.push(address(owner2));
        deal(address(USDC), address(auctionAutoCompounder), USDC_1);
        uint256 balanceBefore = USDC.balanceOf(address(owner2));
        vm.prank(escrow.team());
        auctionAutoCompounder.sweep(tokensToSweep, recipients);
        assertEq(USDC.balanceOf(address(owner2)), balanceBefore + USDC_1);
    }

    function testName() public {
        // Create auctionAutoCompounder with a name
        vm.prank(escrow.allowedManager());
        mTokenId = escrow.createManagedLockFor(address(owner));

        vm.startPrank(address(owner));
        escrow.approve(address(auctionAutoCompounderFactory), mTokenId);
        escrow.setApprovalForAll(address(owner2), true);
        vm.stopPrank();
        vm.prank(address(owner2));
        auctionAutoCompounder = AuctionAutoCompounder(
            auctionAutoCompounderFactory.createRelay(address(owner), mTokenId, "Test", new bytes(0))
        );

        assertEq(auctionAutoCompounder.name(), "Test");

        // Create an auctionAutoCompounder without a name
        vm.prank(escrow.allowedManager());
        mTokenId = escrow.createManagedLockFor(address(owner));

        vm.startPrank(address(owner));
        escrow.approve(address(auctionAutoCompounderFactory), mTokenId);
        escrow.setApprovalForAll(address(owner2), true);
        vm.stopPrank();
        vm.prank(address(owner2));
        auctionAutoCompounder = AuctionAutoCompounder(auctionAutoCompounderFactory.createRelay(address(owner), mTokenId, "", new bytes(0)));

        assertEq(auctionAutoCompounder.name(), "");
    }

    function testSetName() public {
        assertEq(auctionAutoCompounder.name(), "");
        vm.startPrank(address(owner));
        auctionAutoCompounder.setName("New name");
        assertEq(auctionAutoCompounder.name(), "New name");
        auctionAutoCompounder.setName("Second new name");
        assertEq(auctionAutoCompounder.name(), "Second new name");
    }

    function testCannotSetNameIfNotAdmin() public {
        bytes memory revertString = bytes(
            "AccessControl: account 0x7d28001937fe8e131f76dae9e9947adedbd0abde is missing role 0x0000000000000000000000000000000000000000000000000000000000000000"
        );
        vm.startPrank(address(owner2));
        vm.expectRevert(revertString);
        auctionAutoCompounder.setName("Some totally new name");
    }

    function testCannotSetOptimizerIfNotApproved() public {
        address unapprovedOptimizer = vm.addr(0x123);
        vm.expectRevert(IRelay.OptimizerNotApproved.selector);
        auctionAutoCompounder.setOptimizer(unapprovedOptimizer);
    }

    function testCannotSetOptimizerToZeroAddress() public {
        vm.expectRevert(IRelay.ZeroAddress.selector);
        auctionAutoCompounder.setOptimizer(address(0));
    }

    function testSetOptimizer() public {
        address approvedOptimizer = vm.addr(0x123);
        optimizerRegistry.approve(approvedOptimizer);
        auctionAutoCompounder.setOptimizer(approvedOptimizer);
        assertEq(address(auctionAutoCompounder.optimizer()), approvedOptimizer);
    }

    function testCannotSetOptimizerIfNotAdmin() public {
        address approvedOptimizer = vm.addr(0x123);
        optimizerRegistry.approve(approvedOptimizer);
        bytes memory revertString = bytes(
            "AccessControl: account 0x7d28001937fe8e131f76dae9e9947adedbd0abde is missing role 0x0000000000000000000000000000000000000000000000000000000000000000"
        );
        vm.prank(address(owner2));
        vm.expectRevert(revertString);
        auctionAutoCompounder.setOptimizer(approvedOptimizer);
    }
}
